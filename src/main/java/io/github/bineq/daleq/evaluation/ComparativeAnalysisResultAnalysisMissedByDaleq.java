package io.github.bineq.daleq.evaluation;

import com.github.difflib.patch.AbstractDelta;
import com.google.common.base.Preconditions;
import io.github.bineq.daleq.evaluation.tools.Diff;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Stream;

/**
 * Analyse the IDB diffs generated when DALEQ evaluation resulted in non-equivalence.
 * @author jens dietrich
 */
public class ComparativeAnalysisResultAnalysisMissedByDaleq {

    public static final String DALEQ_DIFF = "daleq-diff.txt";

    enum Cause {
        OTHER,CHECKCAST,ANNOTATION
    }

    public static void main(String[] args) throws IOException {
        Preconditions.checkArgument(args.length>0,"one argument required, the output folder generated by " + RunComparativeEvaluation.class);
        Path reportRoot = Path.of(args[0]);
        Preconditions.checkState(Files.exists(reportRoot),"report folder does not exist: " + reportRoot);
        Preconditions.checkState(Files.isDirectory(reportRoot),"report folder is not a directory: " + reportRoot);

        Map<Cause,Integer> counters = new HashMap<>();
        try (Stream<Path> stream = Files.walk(reportRoot)) {
            stream.filter(Files::isRegularFile)
                .filter(path -> path.getFileName().toString().equals(DALEQ_DIFF))
                .map(path -> {
                    try {
                        return Diff.parse(path);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                })
                .forEach(patch -> {
                    EnumSet<Cause> result = analyseDeltas(patch.getDeltas());
                    for (Cause cause : result) {
                        counters.compute(cause, (k,v) -> v == null ? 1 : v + 1);
                    }
                });
        }
    }

    private static EnumSet<Cause> analyseDeltas(List<AbstractDelta<String>> deltas) {
        EnumSet<Cause> result = EnumSet.noneOf(Cause.class);
        for (AbstractDelta<String> delta:deltas) {
            EnumSet<Cause> partResult = analyseDelta(delta);
            result.addAll(partResult);
        }

        if (result.isEmpty()) {
            result.add(Cause.OTHER);
        }
        return result;
    }

    private static EnumSet<Cause> analyseDelta(AbstractDelta<String> delta) {
        List<String> sourceLines = new ArrayList(delta.getSource().getLines()); // make sure that this is mutable
        List<String> targetLines = new ArrayList(delta.getTarget().getLines());

        while (!sourceLines.isEmpty() && !targetLines.isEmpty()) {
            String line1 = sourceLines.get(0);
            String line2 = targetLines.get(0);
            if (line1.equals(line2)) {
                sourceLines.remove(0);
                targetLines.remove(0);
            }
            else {
                break;
            }
        }

        while (!sourceLines.isEmpty() && !targetLines.isEmpty()) {
            String line1 = sourceLines.get(sourceLines.size()-1);
            String line2 = targetLines.get(targetLines.size()-1);
            if (line1.equals(line2)) {
                sourceLines.remove(sourceLines.size()-1);
                targetLines.remove(targetLines.size()-1);
            }
            else {
                break;
            }
        }

        return analyseDelta(sourceLines, targetLines);
    }

    private static EnumSet<Cause> analyseDelta(List<String> lines1, List<String> lines2) {
        EnumSet<Cause> result = EnumSet.noneOf(Cause.class);
        if (anyLineStartsWith(lines1,lines2,"IDB_ANNOTATION")) {
            result.add(Cause.ANNOTATION);
        }
        if (anyLineStartsWith(lines1,lines2,"IDB_CHECKCAST")) {
            result.add(Cause.CHECKCAST);
        }
        if (result.isEmpty()) {
            result.add(Cause.OTHER);
        }
        return result;
    }

    private static boolean anyLineStartsWith(List<String> lines1,List<String> lines2,String predicate) {
        for (String line:lines1) {
            if (line.startsWith(predicate)) {
                return true;
            }
        }
        for (String line:lines2) {
            if (line.startsWith(predicate)) {
                return true;
            }
        }
        return false;
    }

}
